// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'spacing_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$EufemiaSpacingDataTearOff {
  const _$EufemiaSpacingDataTearOff();

  _EufemiaSpacingData _(
      {@required double extraSmall,
      @required double small,
      @required double medium,
      @required double large,
      @required double extraLarge,
      @required double extraExtraLarge}) {
    return _EufemiaSpacingData(
      extraSmall: extraSmall,
      small: small,
      medium: medium,
      large: large,
      extraLarge: extraLarge,
      extraExtraLarge: extraExtraLarge,
    );
  }
}

// ignore: unused_element
const $EufemiaSpacingData = _$EufemiaSpacingDataTearOff();

mixin _$EufemiaSpacingData {
  double get extraSmall;
  double get small;
  double get medium;
  double get large;
  double get extraLarge;
  double get extraExtraLarge;

  $EufemiaSpacingDataCopyWith<EufemiaSpacingData> get copyWith;
}

abstract class $EufemiaSpacingDataCopyWith<$Res> {
  factory $EufemiaSpacingDataCopyWith(
          EufemiaSpacingData value, $Res Function(EufemiaSpacingData) then) =
      _$EufemiaSpacingDataCopyWithImpl<$Res>;
  $Res call(
      {double extraSmall,
      double small,
      double medium,
      double large,
      double extraLarge,
      double extraExtraLarge});
}

class _$EufemiaSpacingDataCopyWithImpl<$Res>
    implements $EufemiaSpacingDataCopyWith<$Res> {
  _$EufemiaSpacingDataCopyWithImpl(this._value, this._then);

  final EufemiaSpacingData _value;
  // ignore: unused_field
  final $Res Function(EufemiaSpacingData) _then;

  @override
  $Res call({
    Object extraSmall = freezed,
    Object small = freezed,
    Object medium = freezed,
    Object large = freezed,
    Object extraLarge = freezed,
    Object extraExtraLarge = freezed,
  }) {
    return _then(_value.copyWith(
      extraSmall:
          extraSmall == freezed ? _value.extraSmall : extraSmall as double,
      small: small == freezed ? _value.small : small as double,
      medium: medium == freezed ? _value.medium : medium as double,
      large: large == freezed ? _value.large : large as double,
      extraLarge:
          extraLarge == freezed ? _value.extraLarge : extraLarge as double,
      extraExtraLarge: extraExtraLarge == freezed
          ? _value.extraExtraLarge
          : extraExtraLarge as double,
    ));
  }
}

abstract class _$EufemiaSpacingDataCopyWith<$Res>
    implements $EufemiaSpacingDataCopyWith<$Res> {
  factory _$EufemiaSpacingDataCopyWith(
          _EufemiaSpacingData value, $Res Function(_EufemiaSpacingData) then) =
      __$EufemiaSpacingDataCopyWithImpl<$Res>;
  @override
  $Res call(
      {double extraSmall,
      double small,
      double medium,
      double large,
      double extraLarge,
      double extraExtraLarge});
}

class __$EufemiaSpacingDataCopyWithImpl<$Res>
    extends _$EufemiaSpacingDataCopyWithImpl<$Res>
    implements _$EufemiaSpacingDataCopyWith<$Res> {
  __$EufemiaSpacingDataCopyWithImpl(
      _EufemiaSpacingData _value, $Res Function(_EufemiaSpacingData) _then)
      : super(_value, (v) => _then(v as _EufemiaSpacingData));

  @override
  _EufemiaSpacingData get _value => super._value as _EufemiaSpacingData;

  @override
  $Res call({
    Object extraSmall = freezed,
    Object small = freezed,
    Object medium = freezed,
    Object large = freezed,
    Object extraLarge = freezed,
    Object extraExtraLarge = freezed,
  }) {
    return _then(_EufemiaSpacingData(
      extraSmall:
          extraSmall == freezed ? _value.extraSmall : extraSmall as double,
      small: small == freezed ? _value.small : small as double,
      medium: medium == freezed ? _value.medium : medium as double,
      large: large == freezed ? _value.large : large as double,
      extraLarge:
          extraLarge == freezed ? _value.extraLarge : extraLarge as double,
      extraExtraLarge: extraExtraLarge == freezed
          ? _value.extraExtraLarge
          : extraExtraLarge as double,
    ));
  }
}

class _$_EufemiaSpacingData implements _EufemiaSpacingData {
  const _$_EufemiaSpacingData(
      {@required this.extraSmall,
      @required this.small,
      @required this.medium,
      @required this.large,
      @required this.extraLarge,
      @required this.extraExtraLarge})
      : assert(extraSmall != null),
        assert(small != null),
        assert(medium != null),
        assert(large != null),
        assert(extraLarge != null),
        assert(extraExtraLarge != null);

  @override
  final double extraSmall;
  @override
  final double small;
  @override
  final double medium;
  @override
  final double large;
  @override
  final double extraLarge;
  @override
  final double extraExtraLarge;

  @override
  String toString() {
    return 'EufemiaSpacingData._(extraSmall: $extraSmall, small: $small, medium: $medium, large: $large, extraLarge: $extraLarge, extraExtraLarge: $extraExtraLarge)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EufemiaSpacingData &&
            (identical(other.extraSmall, extraSmall) ||
                const DeepCollectionEquality()
                    .equals(other.extraSmall, extraSmall)) &&
            (identical(other.small, small) ||
                const DeepCollectionEquality().equals(other.small, small)) &&
            (identical(other.medium, medium) ||
                const DeepCollectionEquality().equals(other.medium, medium)) &&
            (identical(other.large, large) ||
                const DeepCollectionEquality().equals(other.large, large)) &&
            (identical(other.extraLarge, extraLarge) ||
                const DeepCollectionEquality()
                    .equals(other.extraLarge, extraLarge)) &&
            (identical(other.extraExtraLarge, extraExtraLarge) ||
                const DeepCollectionEquality()
                    .equals(other.extraExtraLarge, extraExtraLarge)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(extraSmall) ^
      const DeepCollectionEquality().hash(small) ^
      const DeepCollectionEquality().hash(medium) ^
      const DeepCollectionEquality().hash(large) ^
      const DeepCollectionEquality().hash(extraLarge) ^
      const DeepCollectionEquality().hash(extraExtraLarge);

  @override
  _$EufemiaSpacingDataCopyWith<_EufemiaSpacingData> get copyWith =>
      __$EufemiaSpacingDataCopyWithImpl<_EufemiaSpacingData>(this, _$identity);
}

abstract class _EufemiaSpacingData implements EufemiaSpacingData {
  const factory _EufemiaSpacingData(
      {@required double extraSmall,
      @required double small,
      @required double medium,
      @required double large,
      @required double extraLarge,
      @required double extraExtraLarge}) = _$_EufemiaSpacingData;

  @override
  double get extraSmall;
  @override
  double get small;
  @override
  double get medium;
  @override
  double get large;
  @override
  double get extraLarge;
  @override
  double get extraExtraLarge;
  @override
  _$EufemiaSpacingDataCopyWith<_EufemiaSpacingData> get copyWith;
}
